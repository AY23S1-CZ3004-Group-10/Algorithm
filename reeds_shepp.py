from utils import *
import math
from enum import Enum
from dataclasses import dataclass, replace
from pillars import get_pillars
from params import ARENA_WIDTH, ARENA_HEIGHT, MIN_RADIUS

class Steering(Enum):
    LEFT = -1
    RIGHT = 1
    STRAIGHT = 0


class Gear(Enum):
    FORWARD = 1
    BACKWARD = -1

@dataclass(eq=True)
class PathElement:
    param: float
    steering: Steering
    gear: Gear

    @classmethod
    def create(cls, param: float, steering: Steering, gear: Gear):
        if param >= 0:
            return cls(param, steering, gear)
        else:
            return cls(-param, steering, gear).reverse_gear()

    def __repr__(self):
        s = "{ Steering: " + self.steering.name + "\tGear: " + self.gear.name \
            + "\tdistance: " + str(round(self.param, 2)) + " }"
        return s

    def reverse_steering(self):
        steering = Steering(-self.steering.value)
        return replace(self, steering=steering)

    def reverse_gear(self):
        gear = Gear(-self.gear.value)
        return replace(self, gear=gear)

def boundary_check(x, y):
    """ Check if the robot is inside the arena boundaries. """
    if x < 0 or x > ARENA_WIDTH or y < 0 or y > ARENA_HEIGHT:
        return False
    return True

def collision_check(x, y, pillars):
    """ Check if the robot collides with any of the pillars. """
    for pillar in pillars:
        # Robot's distance from the pillar's center
        dist = ((x - pillar.x - 5)**2 + (y - pillar.y - 5)**2) ** 0.5

        # If the distance is less than the sum of robot radius and pillar's inflated collision zone, it's a collision
        if dist < (15 + 15): # robot's half-width + pillar's inflated collision zone's half-width
            return True
    return False

def path_length(path):
    """
    Return sum of all the segments in the path
    """
    return sum([e.param for e in path])


def get_optimal_path(start, end):
    """
    Return the shortest path from start to end among those that exist
    """
    paths = get_all_paths(start, end)
    if not paths:
        return None
    
    min_path = min(paths, key=path_length)
    print(f"Shortest distance: {path_length(min_path):.2f}")

    return min_path

def get_all_paths(start, end):
    """
    Return a list of all the paths from start to end generated by the
    12 functions and their variants
    """
    path_fns = [path1, path2, path3, path4, path5, path6,
                path7, path8, path9, path10, path11, path12]
    
    paths = []
    path_infos = []

    # get coordinates of end in the set of axis where start is (0,0,0)
    x, y, theta = change_of_basis(start, end)

    for idx, get_path in enumerate(path_fns):
        # get the four variants for each path type, cf article
        paths_variants = [
            ("Original", get_path(x, y, theta)),
            ("Timeflip", timeflip(get_path(-x, y, -theta))),
            ("Reflect", reflect(get_path(x, -y, -theta))),
            ("Reflect Timeflip", reflect(timeflip(get_path(-x, -y, theta))))
        ]

        for variant_name, variant_path in paths_variants:
            # for e in variant_path:
                # print(type(e), e)

            # Remove path elements that have parameter 0
            variant_path = list(filter(lambda e: e.param != 0, variant_path))
            
            if not variant_path:
                path_infos.append(f"Path {idx + 1}, {variant_name}: Invalid")
            else:
                length = path_length(variant_path)
                path_infos.append(f"Path {idx + 1}, {variant_name}: Length = {length:.2f}")
                paths.append(variant_path)
    
    # print("\nAll Path Infos:")
    # for info in path_infos:
    #     print(info)

    return paths

def get_sorted_paths(start, end):
    """
    Return a list of all paths from start to end, sorted by their length
    """
    paths = get_all_paths(start, end)
    
    # Sort the paths by their length
    sorted_paths = sorted(paths, key=path_length)

    return sorted_paths

def timeflip(path):
    """
    timeflip transform described around the end of the article
    """
    new_path = [e.reverse_gear() for e in path]
    return new_path


def reflect(path):
    """
    reflect transform described around the end of the article
    """
    new_path = [e.reverse_steering() for e in path]
    return new_path

def path1(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.1: CSC (same turns)
    """
    phi = deg2rad(phi)
    path = []

    u, t = R(x - r * math.sin(phi), y - r + r * math.cos(phi))

    v = M(phi - t)

    # Calculate lengths for each segment
    length_t = abs(r * t)  # length of the first circular segment
    length_u = u  # length of the straight segment
    length_v = abs(r * v)  # length of the second circular segment

    path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
    path.append(PathElement.create(length_u, Steering.STRAIGHT, Gear.FORWARD))
    path.append(PathElement.create(length_v, Steering.LEFT, Gear.FORWARD))

    return path

def path2(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.2: CSC (opposite turns)
    """
    phi = M(deg2rad(phi))
    path = []

    rho, t1 = R(x + r * math.sin(phi), y - r - r * math.cos(phi))

    if rho * rho >= 4 * r * r:  
        u = math.sqrt(rho * rho - 4 * r * r) 
        t = M(t1 + math.atan2(2 * r, u)) 
        v = M(t - phi)

        length_t = t * r
        length_u = u
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.STRAIGHT, Gear.FORWARD))
        path.append(PathElement.create(length_v, Steering.RIGHT, Gear.FORWARD))

    return path

def path3(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.3: C|C|C
    """
    phi = deg2rad(phi)
    path = []

    xi = x - r * math.sin(phi)
    eta = y - r + r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4 * r: 
        A = math.acos(rho / (4 * r))
        t = M(theta + math.pi/2 + A)
        u = M(math.pi - 2*A)
        v = M(phi - t - u)

        length_t = t * r
        length_u = u * r
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.RIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_v, Steering.LEFT, Gear.FORWARD))

    return path

def path4(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.4 (1): C|CC
    """
    phi = deg2rad(phi)
    path = []

    xi = x - r * math.sin(phi)
    eta = y - r + r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4 * r: 
        A = math.acos(rho / (4 * r)) 
        t = M(theta + math.pi/2 + A)
        u = M(math.pi - 2*A)
        v = M(t + u - phi)

        length_t = t * r
        length_u = u * r
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.RIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_v, Steering.LEFT, Gear.BACKWARD))

    return path

def path5(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.4 (2): CC|C
    """
    phi = deg2rad(phi)
    path = []

    xi = x - r * math.sin(phi)
    eta = y - r + r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4 * r:
        u = math.acos(1 - rho*rho/(8 * r * r))
        A = math.asin(2 * r * math.sin(u) / rho)
        t = M(theta + math.pi/2 - A)
        v = M(t - u - phi)

        length_t = t * r
        length_u = u * r
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.RIGHT, Gear.FORWARD))
        path.append(PathElement.create(length_v, Steering.LEFT, Gear.BACKWARD))

    return path

def path6(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.7: CCu|CuC
    """
    phi = deg2rad(phi)
    path = []

    xi = x + r * math.sin(phi)
    eta = y - r - r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho <= 4 * r:  
        if rho <= 2 * r:  
            A = math.acos((rho + 2 * r) / (4 * r))  
            t = M(theta + math.pi/2 + A)
            u = M(A)
            v = M(phi - t + 2*u)
        else:
            A = math.acos((rho - 2 * r) / (4 * r))  
            t = M(theta + math.pi/2 - A)
            u = M(math.pi - A)
            v = M(phi - t + 2*u)

        length_t = t * r
        length_u = u * r
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.RIGHT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.LEFT, Gear.BACKWARD))  # Note that 'u' is used again here
        path.append(PathElement.create(length_v, Steering.RIGHT, Gear.BACKWARD))

    return path

def path7(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.8: C|CuCu|C
    """
    phi = deg2rad(phi)
    path = []

    xi = x + r * math.sin(phi)
    eta = y - r - r * math.cos(phi)
    rho, theta = R(xi, eta)

    u1 = (20 * r * r - rho * rho) / (16 * r * r) 
    if rho <= 6 * r and 0 <= u1 <= 1: 
        u = math.acos(u1)
        A = math.asin(2 * r * math.sin(u) / rho)  
        t = M(theta + math.pi/2 + A)
        v = M(t - phi)

        length_t = t * r
        length_u = u * r
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.RIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_u, Steering.LEFT, Gear.BACKWARD))  # Note that 'u' is used again here
        path.append(PathElement.create(length_v, Steering.RIGHT, Gear.FORWARD))

    return path

def path8(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.9 (1): C|C[pi/2]SC
    """
    phi = deg2rad(phi)
    path = []

    xi = x - r * math.sin(phi)
    eta = y - r + r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2 * r:  
        u = math.sqrt(rho*rho - 4*r*r) - 2*r  
        A = math.atan2(2 * r, u + 2 * r)
        t = M(theta + math.pi/2 + A)
        v = M(t - phi + math.pi/2)

        length_t = t * r
        length_u = u  
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(math.pi/2 * r, Steering.RIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_u, Steering.STRAIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_v, Steering.LEFT, Gear.BACKWARD))

    return path

def path9(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.9 (2): CSC[pi/2]|C
    """
    phi = deg2rad(phi)
    path = []

    xi = x - r * math.sin(phi)
    eta = y - r + r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2 * r:  
        u = math.sqrt(rho*rho - 4*r*r) - 2*r 
        A = math.atan2(u + 2 * r, 2 * r) 
        t = M(theta + math.pi/2 - A)
        v = M(t - phi - math.pi/2)

        length_t = t * r
        length_u = u  
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.STRAIGHT, Gear.FORWARD))
        path.append(PathElement.create(math.pi/2 * r, Steering.RIGHT, Gear.FORWARD))
        path.append(PathElement.create(length_v, Steering.LEFT, Gear.BACKWARD))

    return path

def path10(x, y, phi, r=MIN_RADIUS):
    """
    Formula 8.10 (1): C|C[pi/2]SC
    """
    phi = deg2rad(phi)
    path = []

    xi = x + r * math.sin(phi)
    eta = y - r - r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2 * r: 
        t = M(theta + math.pi/2)
        u = rho - 2*r  # Adjust for r
        v = M(phi - t - math.pi/2)

        length_t = t * r
        length_u = u 
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(math.pi/2 * r, Steering.RIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_u, Steering.STRAIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_v, Steering.RIGHT, Gear.BACKWARD))

    return path

def path11(x, y, phi, r=MIN_RADIUS): 
    """
    Formula 8.10 (2): CSC[pi/2]|C
    """
    phi = deg2rad(phi)
    path = []

    xi = x + r * math.sin(phi)
    eta = y - r - r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 2 * r:
        t = M(theta)
        u = rho - 2*r 
        v = M(phi - t - math.pi/2)

        length_t = t * r
        length_u = u  
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_u, Steering.STRAIGHT, Gear.FORWARD))
        path.append(PathElement.create(math.pi/2 * r, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(length_v, Steering.RIGHT, Gear.BACKWARD))

    return path

def path12(x, y, phi, r=MIN_RADIUS): 
    """
    Formula 8.11: C|C[pi/2]SC[pi/2]|C
    """
    phi = deg2rad(phi)
    path = []

    xi = x + r * math.sin(phi)
    eta = y - r - r * math.cos(phi)
    rho, theta = R(xi, eta)

    if rho >= 4 * r:  
        u = math.sqrt(rho*rho - 4*r*r) - 4*r  
        A = math.atan2(2*r, u + 4*r)  
        t = M(theta + math.pi/2 + A)
        v = M(t - phi)

        length_t = t * r
        length_u = u  
        length_v = v * r

        path.append(PathElement.create(length_t, Steering.LEFT, Gear.FORWARD))
        path.append(PathElement.create(math.pi/2 * r, Steering.RIGHT, Gear.BACKWARD))
        path.append(PathElement.create(length_u, Steering.STRAIGHT, Gear.BACKWARD))
        path.append(PathElement.create(math.pi/2 * r, Steering.LEFT, Gear.BACKWARD))
        path.append(PathElement.create(length_v, Steering.RIGHT, Gear.FORWARD))

    return path



